"""
Main FastAPI application for Confluence Content Intelligence & Enhancement System
"""
import logging
import time
from fastapi import FastAPI, HTTPException, Depends, UploadFile, File
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, Response
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, HttpUrl
from typing import Optional, List, Dict, Any
import asyncio
import uvicorn
from datetime import datetime
from dataclasses import asdict

# Import our modules (note: these imports may show errors in IDE but will work when properly set up)
try:
    from src.api.confluence_client import ConfluenceClient
    from src.api.content_extractor import ContentExtractor
    from src.api.auth_handler import AuthHandler
    from src.api.page_creator import ConfluencePageCreator
    from src.ai_engine.content_analyzer import ContentAnalyzer
    from src.ai_engine.structure_optimizer import StructureOptimizer
    from src.processors.table_processor import TableProcessor
    from src.models.content_model import ContentModel
    from src.utils.config import settings
    from src.utils.helpers import logger, validate_confluence_url
    from src.modernization.technology_modernizer import TechnologyModernizer
    from src.modernization.content_modernizer import ContentModernizer  
    from src.reports.report_generator import InteractiveReportGenerator
    from src.reports.metrics_collector import metrics_collector
    from src.reports.page_publisher import PagePublishingService
    from src.visualizations.dashboard_generator import DashboardGenerator
except ImportError as e:
    # Fallback for development
    print(f"Import warning: {e}")
    logger = logging.getLogger(__name__)

# Fallback settings if not imported properly
try:
    from src.utils.config import settings
except ImportError:
    class FallbackSettings:
        HOST = "0.0.0.0"
        PORT = 8000
        DEBUG = True
    settings = FallbackSettings()


# Initialize FastAPI app
app = FastAPI(
    title="Confluence Content Intelligence & Enhancement System",
    description="AI-powered system for analyzing and enhancing Confluence content",
    version="1.0.0"
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configure appropriately for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Security
security = HTTPBearer()

# Initialize components
try:
    auth_handler = AuthHandler() if 'AuthHandler' in globals() else None
    content_extractor = ContentExtractor() if 'ContentExtractor' in globals() else None
    content_analyzer = ContentAnalyzer() if 'ContentAnalyzer' in globals() else None
    structure_optimizer = StructureOptimizer() if 'StructureOptimizer' in globals() else None
    table_processor = TableProcessor() if 'TableProcessor' in globals() else None
    technology_modernizer = TechnologyModernizer() if 'TechnologyModernizer' in globals() else None
    content_modernizer = ContentModernizer() if 'ContentModernizer' in globals() else None
    report_generator = InteractiveReportGenerator() if 'InteractiveReportGenerator' in globals() else None
    dashboard_generator = DashboardGenerator() if 'DashboardGenerator' in globals() else None
    page_creator = ConfluencePageCreator(settings) if 'ConfluencePageCreator' in globals() else None
    page_publisher = PagePublishingService(settings) if 'PagePublishingService' in globals() else None
except Exception as e:
    print(f"Failed to initialize components: {e}")
    # Create dummy components for development
    auth_handler = None
    content_extractor = None
    content_analyzer = None
    structure_optimizer = None
    table_processor = None
    technology_modernizer = None
    content_modernizer = None
    report_generator = None
    dashboard_generator = None
    page_creator = None
    page_publisher = None


# Pydantic models for API
class AnalysisRequest(BaseModel):
    page_url: HttpUrl
    analysis_options: Optional[Dict[str, bool]] = {
        "structure_analysis": True,
        "quality_analysis": True,
        "table_analysis": True,
        "visualization_generation": True,
        "modernization_analysis": True
    }


class AuthRequest(BaseModel):
    username: str
    password: str


class PageCreationRequest(BaseModel):
    page_url: HttpUrl
    enhanced_content: Dict[str, Any]
    visualizations: Optional[List[Dict[str, Any]]] = None
    options: Optional[Dict[str, Any]] = {
        "preview_only": False,
        "custom_title": None,
        "publish_immediately": True
    }


class BatchPageCreationRequest(BaseModel):
    page_requests: List[Dict[str, Any]]
    batch_options: Optional[Dict[str, Any]] = {
        "max_concurrent": 3,
        "fail_fast": False
    }


class ConfluenceAuthRequest(BaseModel):
    base_url: HttpUrl
    username: str
    api_token: str


class EnhancementRequest(BaseModel):
    content_id: str
    enhancement_types: List[str]


# Dependency for authentication
async def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):
    if not auth_handler:
        return {"user": "dev_user"}  # Development mode
    
    token = credentials.credentials
    payload = auth_handler.verify_token(token)
    
    if not payload:
        raise HTTPException(status_code=401, detail="Invalid or expired token")
    
    return payload


# Root endpoint
@app.get("/")
async def root():
    return {
        "message": "Confluence Content Intelligence & Enhancement System",
        "version": "1.0.0",
        "status": "running"
    }


# Health check
@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "components": {
            "auth_handler": auth_handler is not None,
            "content_extractor": content_extractor is not None,
            "content_analyzer": content_analyzer is not None,
            "structure_optimizer": structure_optimizer is not None,
            "table_processor": table_processor is not None
        }
    }


# Authentication endpoints
@app.post("/auth/login")
async def login(auth_request: AuthRequest):
    if not auth_handler:
        # Development mode
        return {"access_token": "dev_token", "token_type": "bearer"}
    
    user = auth_handler.authenticate_user(auth_request.username, auth_request.password)
    if not user:
        raise HTTPException(status_code=401, detail="Invalid credentials")
    
    access_token = auth_handler.create_access_token({"sub": user["username"]})
    return {"access_token": access_token, "token_type": "bearer"}


@app.post("/auth/confluence")
async def verify_confluence_auth(confluence_auth: ConfluenceAuthRequest, 
                                current_user: dict = Depends(verify_token)):
    if not auth_handler:
        return {"valid": True, "message": "Development mode"}
    
    is_valid = auth_handler.verify_confluence_credentials(
        confluence_auth.username, 
        confluence_auth.api_token
    )
    
    return {"valid": is_valid, "message": "Credentials verified" if is_valid else "Invalid credentials"}


# Content analysis endpoints
@app.post("/analysis/extract")
async def extract_content(analysis_request: AnalysisRequest):
    try:
        page_url = str(analysis_request.page_url)
        
        # Validate URL
        if not page_url or 'atlassian.net' not in page_url:
            raise HTTPException(status_code=400, detail="Invalid Confluence URL")
        
        if not content_extractor:
            raise HTTPException(status_code=503, detail="Content extractor not available")
        
        # Extract content
        content = content_extractor.extract_from_url(page_url)
        if not content:
            raise HTTPException(status_code=404, detail="Failed to extract content from URL")
        
        return {
            "content_id": content.content_id,
            "title": content.title,
            "status": "extracted",
            "metadata": {
                "word_count": len(content.raw_text.split()),
                "url": page_url
            }
        }
        
    except Exception as e:
        logger.error(f"Error extracting content: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/analysis/analyze")
async def analyze_content(analysis_request: AnalysisRequest):
    try:
        page_url = str(analysis_request.page_url)
        options = analysis_request.analysis_options
        
        if not content_extractor:
            raise HTTPException(status_code=503, detail="Content extractor not available")
        
        # Extract content
        content = content_extractor.extract_from_url(page_url)
        if not content:
            raise HTTPException(status_code=404, detail="Failed to extract content")
        
        # Basic analysis using available data
        results = {
            "title": content.title,
            "word_count": len(content.raw_text.split()) if content.raw_text else 0,
            "character_count": len(content.raw_text) if content.raw_text else 0,
            "status": "analyzed",
            "basic_metrics": {
                "has_content": bool(content.raw_text),
                "content_length": len(content.raw_text) if content.raw_text else 0,
                "metadata_available": bool(content.metadata)
            }
        }
        
        # Add advanced analysis if components are available
        if content_analyzer:
            # Structure analysis
            if options.get("structure_analysis", True):
                try:
                    structure_analysis = content_analyzer.analyze_content_structure(content)
                    results["structure"] = structure_analysis.results
                except Exception as e:
                    logger.warning(f"Structure analysis failed: {e}")
            
            # Quality analysis
            if options.get("quality_analysis", True):
                try:
                    quality_analysis = content_analyzer.analyze_content_quality(content)
                    results["quality"] = quality_analysis.results
                except Exception as e:
                    logger.warning(f"Quality analysis failed: {e}")
        
        return {
            "content_id": f"content_{int(time.time())}",
            "url": page_url,
            "analysis": results,
            "timestamp": datetime.now().isoformat()
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error analyzing content: {e}")
        raise HTTPException(status_code=500, detail=f"Analysis failed: {str(e)}")
            
            for table in tables:
                table_analysis = table_processor.analyze_table_structure(table)
                suggestions = table_processor.suggest_visualizations(table, table_analysis)
                dashboard_potential = table_processor.assess_dashboard_potential(table)
                
                table_analyses.append({
                    "table_id": table.table_id,
                    "analysis": table_analysis,
                    "visualization_suggestions": suggestions,
                    "dashboard_potential": dashboard_potential
                })
            
            results["tables"] = table_analyses
        
        return {
            "content_id": content.content_id,
            "title": content.title,
            "analysis_results": results,
            "status": "completed"
        }
        
    except Exception as e:
        logger.error(f"Error analyzing content: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/enhancement/optimize")
async def optimize_content(enhancement_request: EnhancementRequest,
                          current_user: dict = Depends(verify_token)):
    try:
        if not structure_optimizer:
            raise HTTPException(status_code=503, detail="Structure optimizer not available")
        
        # This would typically load content from database
        # For now, return a placeholder response
        
        return {
            "content_id": enhancement_request.content_id,
            "enhancements": [
                {
                    "type": "structure_optimization",
                    "status": "completed",
                    "description": "Optimized heading structure and content flow"
                }
            ],
            "status": "completed"
        }
        
    except Exception as e:
        logger.error(f"Error optimizing content: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/visualization/dashboard/{content_id}")
async def get_dashboard(content_id: str, current_user: dict = Depends(verify_token)):
    try:
        # This would typically load dashboard from database
        # For now, return a sample dashboard structure
        
        return {
            "dashboard_id": f"dashboard_{content_id}",
            "title": "Sample Dashboard",
            "charts": [
                {
                    "chart_id": "chart_1",
                    "type": "line_chart",
                    "title": "Sample Line Chart",
                    "config": {
                        "x_axis": "date",
                        "y_axis": "value"
                    }
                }
            ],
            "filters": [],
            "interactions": {"cross_filter": True}
        }
        
    except Exception as e:
        logger.error(f"Error getting dashboard: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/reports/{content_id}")
async def get_enhancement_report(content_id: str, current_user: dict = Depends(verify_token)):
    try:
        # This would typically generate and return the enhancement report
        # For now, return a sample report structure
        
        return {
            "report_id": f"report_{content_id}",
            "content_id": content_id,
            "executive_summary": "Content has been successfully analyzed and enhanced",
            "improvements": [
                {
                    "type": "structure",
                    "description": "Optimized heading hierarchy",
                    "impact": "high"
                },
                {
                    "type": "visualization",
                    "description": "Generated interactive dashboard",
                    "impact": "medium"
                }
            ],
            "metrics": {
                "enhancement_score": 85,
                "readability_improvement": 25,
                "structure_score": 90
            }
        }
        
    except Exception as e:
        logger.error(f"Error getting report: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# Dashboard generation endpoints
@app.post("/api/dashboard/generate/{content_id}")
async def generate_dashboard(content_id: str):
    """Generate interactive dashboard from content tables"""
    try:
        start_time = time.time()
        
        # Get content from database (placeholder)
        content = {"content_id": content_id, "tables": []}  # Replace with actual DB query
        
        # Process tables and generate dashboard
        if content.get("tables"):
            dashboard_data = dashboard_generator.create_interactive_dashboard(
                content["tables"], 
                []  # visualization suggestions would come from analysis
            )
            
            # Record metrics
            processing_time = time.time() - start_time
            metrics_collector.record_metric("dashboard_generation_time", processing_time)
            
            return {
                "dashboard_id": f"dash_{content_id}",
                "title": f"Dashboard for {content_id}",
                "charts": dashboard_data.get("charts", []),
                "filters": dashboard_data.get("filters", []),
                "summary": dashboard_data.get("summary", {}),
                "metadata": {"generated_at": datetime.now().isoformat()}
            }
        else:
            return {"error": "No tables found to generate dashboard"}
            
    except Exception as e:
        logger.error(f"Error generating dashboard: {e}")
        metrics_collector.record_metric("error_rate", 1, {"endpoint": "dashboard_generate"})
        raise HTTPException(status_code=500, detail=str(e))

# Diagram generation endpoints
@app.post("/api/diagrams/generate/{content_id}")
async def generate_diagrams(content_id: str):
    """Generate diagrams from content processes and concepts"""
    try:
        start_time = time.time()
        
        # Get content analysis (placeholder)
        content_analysis = {"processes": [], "concepts": []}  # Replace with actual data
        
        diagrams = []
        
        # Generate flowcharts from processes
        if content_analysis.get("processes"):
            for process in content_analysis["processes"]:
                diagram = {
                    "diagram_id": f"proc_{len(diagrams)}",
                    "title": process.get("name", "Process Flow"),
                    "type": "mermaid",
                    "code": f"""flowchart TD
    Start([Start])
    Step1[Process Step]
    End([End])
    Start --> Step1
    Step1 --> End""",
                    "description": f"Flowchart for {process.get('name', 'process')}",
                    "format": "mermaid"
                }
                diagrams.append(diagram)
        
        # Record metrics
        processing_time = time.time() - start_time
        metrics_collector.record_metric("diagram_generation_time", processing_time)
        
        return {
            "diagrams": diagrams,
            "total_count": len(diagrams),
            "generated_at": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"Error generating diagrams: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/diagrams/export/{diagram_id}")
async def export_diagram(diagram_id: str, format: str = "svg"):
    """Export diagram in specified format"""
    try:
        # This would typically render the diagram and return the file
        # For now, return a placeholder response
        if format == "svg":
            svg_content = '<svg><text x="10" y="20">Diagram Export Placeholder</text></svg>'
            return Response(content=svg_content, media_type="image/svg+xml")
        elif format == "png":
            # Would typically convert SVG to PNG
            return Response(content=b"PNG placeholder", media_type="image/png")
        else:
            raise HTTPException(status_code=400, detail="Unsupported format")
            
    except Exception as e:
        logger.error(f"Error exporting diagram: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# Modernization endpoints
@app.post("/api/modernization/analyze/{content_id}")
async def analyze_modernization(content_id: str):
    """Analyze content for modernization opportunities"""
    try:
        start_time = time.time()
        
        # Get content (placeholder)
        content = {"content_id": content_id, "raw_text": "Sample content"}
        
        # Analyze technology modernization
        tech_suggestions = technology_modernizer.analyze_content(
            content["raw_text"], content_id
        )
        
        # Analyze content modernization  
        content_suggestions = content_modernizer.analyze_content(
            content["raw_text"], content_id
        )
        
        # Record metrics
        processing_time = time.time() - start_time
        metrics_collector.record_metric("modernization_analysis_time", processing_time)
        
        return {
            "content_id": content_id,
            "technology_suggestions": [asdict(s) for s in tech_suggestions],
            "content_suggestions": [asdict(s) for s in content_suggestions],
            "analysis_timestamp": datetime.now().isoformat(),
            "total_suggestions": len(tech_suggestions) + len(content_suggestions)
        }
        
    except Exception as e:
        logger.error(f"Error analyzing modernization: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/modernization/roadmap")
async def generate_modernization_roadmap(request: dict):
    """Generate modernization implementation roadmap"""
    try:
        tech_suggestions = request.get("technology_suggestions", [])
        content_suggestions = request.get("content_suggestions", [])
        
        # Convert back to objects (simplified)
        all_suggestions = tech_suggestions + content_suggestions
        
        # Generate roadmap
        roadmap = technology_modernizer.get_modernization_roadmap(all_suggestions)
        
        return {
            "roadmap": roadmap,
            "generated_at": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"Error generating roadmap: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# Suggestion management endpoints
@app.post("/api/suggestions/accept/{suggestion_id}")
async def accept_suggestion(suggestion_id: str):
    """Accept and implement a suggestion"""
    try:
        # Record acceptance (would typically update database)
        metrics_collector.record_metric("suggestions_accepted", 1)
        
        return {
            "suggestion_id": suggestion_id,
            "status": "accepted",
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"Error accepting suggestion: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# Report generation endpoints
@app.post("/api/reports/generate/{content_id}")
async def generate_comprehensive_report(content_id: str):
    """Generate comprehensive enhancement report"""
    try:
        start_time = time.time()
        
        # Gather all analysis data
        content_analysis = {}  # Would get from database
        enhancement_suggestions = []  # Would get from analysis
        modernization_suggestions = []  # Would get from modernization
        visualization_recommendations = []  # Would get from dashboard/diagram analysis
        content_metadata = {"url": "", "title": "", "length": 0}
        
        # Generate comprehensive report
        report = report_generator.generate_comprehensive_report(
            content_analysis,
            enhancement_suggestions,
            modernization_suggestions,
            visualization_recommendations,
            content_metadata
        )
        
        # Record metrics
        processing_time = time.time() - start_time
        metrics_collector.record_metric("report_generation_time", processing_time)
        
        return {
            "report": asdict(report),
            "generated_at": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"Error generating report: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/reports/export/{report_id}")
async def export_report(report_id: str, format: str = "html"):
    """Export report in specified format"""
    try:
        # Would typically get report from database and export
        if format == "html":
            html_content = "<html><body><h1>Report Export Placeholder</h1></body></html>"
            return Response(content=html_content, media_type="text/html")
        elif format == "pdf":
            return Response(content=b"PDF placeholder", media_type="application/pdf")
        elif format == "json":
            return {"report_id": report_id, "data": "placeholder"}
        else:
            raise HTTPException(status_code=400, detail="Unsupported format")
            
    except Exception as e:
        logger.error(f"Error exporting report: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# Metrics and monitoring endpoints
@app.get("/api/metrics/summary")
async def get_metrics_summary():
    """Get system metrics summary"""
    try:
        summary = metrics_collector.get_metrics_summary()
        return asdict(summary)
    except Exception as e:
        logger.error(f"Error getting metrics: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/metrics/health")
async def get_system_health():
    """Get system health status"""
    try:
        health = metrics_collector.get_system_health()
        return health
    except Exception as e:
        logger.error(f"Error getting health status: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/metrics/performance")
async def get_performance_metrics():
    """Get performance metrics"""
    try:
        performance = metrics_collector.get_performance_metrics()
        return performance
    except Exception as e:
        logger.error(f"Error getting performance metrics: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/pages/create")
async def create_enhanced_page(request: PageCreationRequest):
    """Create an enhanced Confluence page with timestamp naming"""
    try:
        # Validate the page URL
        page_url = str(request.page_url)
        if not validate_confluence_url(page_url):
            raise HTTPException(status_code=400, detail="Invalid Confluence URL")
        
        # Create the enhanced page
        result = await page_creator.create_enhanced_page(
            original_page_url=page_url,
            enhanced_content=request.enhanced_content,
            visualizations=request.visualizations,
            options=request.options
        )
        
        # Track the operation
        if metrics_collector:
            metrics_collector.record_metric("page_creation_success", 1)
        
        return {
            "success": True,
            "page_info": result,
            "message": f"Enhanced page created: {result.get('title', 'Unknown')}"
        }
        
    except Exception as e:
        if metrics_collector:
            metrics_collector.record_metric("page_creation_error", 1)
        raise HTTPException(status_code=500, detail=f"Page creation failed: {str(e)}")


@app.post("/api/pages/batch-create")
async def batch_create_enhanced_pages(request: BatchPageCreationRequest):
    """Create multiple enhanced Confluence pages"""
    try:
        # Publish batch of pages
        results = await page_publisher.publish_batch(
            page_requests=request.page_requests,
            options=request.batch_options
        )
        
        # Track batch operation
        if metrics_collector:
            success_count = sum(1 for r in results if r.get("success"))
            error_count = len(results) - success_count
            metrics_collector.record_metric("batch_page_creation_success", success_count)
            metrics_collector.record_metric("batch_page_creation_error", error_count)
        
        return {
            "success": True,
            "results": results,
            "summary": {
                "total": len(results),
                "successful": sum(1 for r in results if r.get("success")),
                "failed": sum(1 for r in results if not r.get("success"))
            }
        }
        
    except Exception as e:
        if metrics_collector:
            metrics_collector.record_metric("batch_page_creation_error", 1)
        raise HTTPException(status_code=500, detail=f"Batch page creation failed: {str(e)}")


@app.get("/api/pages/status/{page_id}")
async def get_page_status(page_id: str):
    """Get the status of a created page"""
    try:
        status = await page_publisher.get_page_status(page_id)
        return {
            "success": True,
            "status": status
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Status check failed: {str(e)}")


@app.get("/api/pages/statistics")
async def get_publishing_statistics():
    """Get page publishing statistics"""
    try:
        stats = await page_publisher.get_statistics()
        return {
            "success": True,
            "statistics": stats
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Statistics retrieval failed: {str(e)}")


# Error handlers
@app.exception_handler(Exception)
async def general_exception_handler(request, exc):
    logger.error(f"Unhandled exception: {exc}")
    return JSONResponse(
        status_code=500,
        content={"detail": "Internal server error"}
    )


if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host=settings.HOST,
        port=settings.PORT,
        reload=settings.DEBUG,
        log_level="info"
    )
